import 'package:flame/components.dart';
import 'package:temple_run_2d/models/character.dart';

class PlayerComponent extends SpriteAnimationComponent {
  final GameCharacter character;
  final double gravity;
  final double laneWidth;
  final int lanesCount;

  int currentLane = 1; // 0: left, 1: center, 2: right
  double verticalVelocity = 0;
  bool isJumping = false;
  bool isDead = false;

  // Animation states
  late SpriteAnimation runAnimation;
  late SpriteAnimation jumpAnimation;
  late SpriteAnimation slideAnimation;
  late SpriteAnimation deathAnimation;

  PlayerComponent({
    required this.character,
    required Vector2 position,
    required Vector2 size,
    required this.gravity,
    required this.laneWidth,
    required this.lanesCount,
  }) : super(position: position, size: size);

  @override
  Future<void> onLoad() async {
    // Load animations
    // In a real game, these would be loaded from sprite sheets
    // For this example, we'll use placeholder animations
    runAnimation = SpriteAnimation.spriteList(
      [
        await Sprite.load('player/run1.png'),
        await Sprite.load('player/run2.png')
      ],
      stepTime: 0.1,
    );

    jumpAnimation = SpriteAnimation.spriteList(
      [await Sprite.load('player/jump.png')],
      stepTime: 0.1,
    );

    slideAnimation = SpriteAnimation.spriteList(
      [await Sprite.load('player/slide.png')],
      stepTime: 0.1,
    );

    deathAnimation = SpriteAnimation.spriteList(
      [await Sprite.load('player/death.png')],
      stepTime: 0.1,
    );

    // Set initial animation
    animation = runAnimation;

    return super.onLoad();
  }

  @override
  void update(double dt) {
    if (isDead) return;

    // Apply gravity if jumping
    if (isJumping) {
      verticalVelocity += gravity * dt;
      position.y += verticalVelocity * dt;

      // Check if landed
      final groundY = (parent is HasGameRef
              ? (parent as HasGameRef).gameRef.size.y
              : 600.0) -
          100;
      if (position.y >= groundY) {
        position.y = groundY;
        isJumping = false;
        verticalVelocity = 0;
        animation = runAnimation;
      }
    }

    // Update horizontal position based on lane
    final targetX = currentLane * laneWidth + laneWidth / 2;
    position.x += (targetX - position.x) * 10 * dt;

    super.update(dt);
  }

  void jump() {
    if (!isJumping && !isDead) {
      isJumping = true;
      verticalVelocity = -600; // Jump velocity
      animation = jumpAnimation;
      // Play jump sound
      // In a real game, you would add sound effects here
    }
  }

  void moveLeft() {
    if (!isDead && currentLane > 0) {
      currentLane--;
      // Play move sound
    }
  }

  void moveRight() {
    if (!isDead && currentLane < lanesCount - 1) {
      currentLane++;
      // Play move sound
    }
  }

  void die() {
    isDead = true;
    animation = deathAnimation;
    // Play death sound
  }

  void reset() {
    isDead = false;
    isJumping = false;
    verticalVelocity = 0;
    final groundY =
        (parent is HasGameRef ? (parent as HasGameRef).gameRef.size.y : 600.0) -
            100;
    position.y = groundY;
    animation = runAnimation;
  }
}
