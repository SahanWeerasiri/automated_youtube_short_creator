import 'dart:async';
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flame/events.dart';
import 'package:flame/game.dart';
import 'package:flame/parallax.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';
import 'package:temple_run_2d/game/components/coin.dart';
import 'package:temple_run_2d/game/components/gem.dart';
import 'package:temple_run_2d/game/components/obstacle.dart';
import 'package:temple_run_2d/game/components/player_component.dart';
import 'package:temple_run_2d/models/character.dart';

class TempleRunGame extends FlameGame with KeyboardEvents, TapDetector {
  // Callbacks
  final VoidCallback onGameOver;
  final VoidCallback onCollectCoin;
  final VoidCallback onCollectGem;
  final VoidCallback onAvoidObstacle;

  // Game components
  late PlayerComponent player;
  final List<Component> gameComponents = [];

  // Game settings
  final GameCharacter character;
  final double gravity = 1000;
  final double initialSpeed = 300;
  double gameSpeed = 1.0;
  double spawnTimer = 0;
  double obstacleSpawnRate = 1.5; // seconds
  double coinSpawnRate = 1.0; // seconds
  double gemSpawnRate = 3.0; // seconds
  double coinTimer = 0;
  double gemTimer = 0;
  double distanceTraveled = 0;
  bool isGameOver = false;

  // Lanes
  final int lanesCount = 3;
  late double laneWidth;

  // Random generator
  final Random random = Random();

  TempleRunGame({
    required this.onGameOver,
    required this.onCollectCoin,
    required this.onCollectGem,
    required this.onAvoidObstacle,
    required this.character,
  });

  @override
  Future<void> onLoad() async {
    // Load background
    final parallaxBackground = await loadParallaxComponent(
      [
        ParallaxImageData('background/sky.png'),
        ParallaxImageData('background/mountains.png'),
        ParallaxImageData('background/trees.png'),
        ParallaxImageData('background/foreground.png'),
      ],
      baseVelocity: Vector2(0, 0),
      velocityMultiplierDelta: Vector2(1.1, 1.0),
    );
    add(parallaxBackground);

    // Calculate lane width
    laneWidth = size.x / lanesCount;

    // Add player
    player = PlayerComponent(
      character: character,
      position: Vector2(size.x / 2, size.y - 100),
      size: Vector2(64, 64),
      gravity: gravity,
      laneWidth: laneWidth,
      lanesCount: lanesCount,
    );
    add(player);

    return super.onLoad();
  }

  @override
  void update(double dt) {
    if (isGameOver) return;

    // Update game speed based on distance
    gameSpeed = 1.0 + (distanceTraveled / 5000) * 0.5;
    if (gameSpeed > 2.5) gameSpeed = 2.5;

    // Apply character speed multiplier
    final effectiveSpeed = gameSpeed * character.speedMultiplier;

    // Update distance traveled
    distanceTraveled += initialSpeed * effectiveSpeed * dt;

    // Update spawn timers
    spawnTimer += dt;
    coinTimer += dt;
    gemTimer += dt;

    // Spawn obstacles
    if (spawnTimer >= obstacleSpawnRate / effectiveSpeed) {
      spawnObstacle();
      spawnTimer = 0;
    }

    // Spawn coins
    if (coinTimer >= coinSpawnRate / effectiveSpeed) {
      spawnCoin();
      coinTimer = 0;
    }

    // Spawn gems
    if (gemTimer >= gemSpawnRate / effectiveSpeed) {
      spawnGem();
      gemTimer = 0;
    }

    // Check for collisions

    final componentsToRemove = <Component>[];
    for (final component in gameComponents) {
      if (component is Obstacle && component.collidesWithPlayer(player)) {
        gameOver();
        break;
      } else if (component is Coin && component.collidesWithPlayer(player)) {
        component.removeFromParent();
        componentsToRemove.add(component);
        onCollectCoin();
      } else if (component is Gem && component.collidesWithPlayer(player)) {
        component.removeFromParent();
        componentsToRemove.add(component);
        onCollectGem();
      }
    }
    // Remove off-screen components
    gameComponents.removeWhere((component) {
      if (component is PositionComponent &&
          component.position.y > size.y + 100) {
        component.removeFromParent();
        if (component is Obstacle) {
          onAvoidObstacle();
        }
        return true;
      }
      return false;
    });

    super.update(dt);
  }

  void spawnObstacle() {
    final lane = random.nextInt(lanesCount);
    final obstacleType = random.nextInt(3); // 0: rock, 1: log, 2: pit

    final obstacle = Obstacle(
      type: obstacleType,
      position: Vector2(lane * laneWidth + laneWidth / 2, -50),
      size: Vector2(laneWidth * 0.8, 40),
      speed: initialSpeed * gameSpeed,
    );

    add(obstacle);
    gameComponents.add(obstacle);
  }

  void spawnCoin() {
    final lane = random.nextInt(lanesCount);
    final coinCount = random.nextInt(3) + 1; // 1-3 coins in a row

    for (var i = 0; i < coinCount; i++) {
      final coin = Coin(
        position: Vector2(lane * laneWidth + laneWidth / 2, -50 - i * 60),
        size: Vector2(30, 30),
        speed: initialSpeed * gameSpeed,
      );

      add(coin);
      gameComponents.add(coin);
    }
  }

  void spawnGem() {
    final lane = random.nextInt(lanesCount);

    final gem = Gem(
      position: Vector2(lane * laneWidth + laneWidth / 2, -50),
      size: Vector2(40, 40),
      speed: initialSpeed * gameSpeed,
    );

    add(gem);
    gameComponents.add(gem);
  }

  void gameOver() {
    isGameOver = true;
    player.die();
    onGameOver();
  }

  void reset() {
    // Remove all game components
    for (final component in gameComponents) {
      component.removeFromParent();
    }
    gameComponents.clear();

    // Reset game state
    gameSpeed = 1.0;
    spawnTimer = 0;
    coinTimer = 0;
    gemTimer = 0;
    distanceTraveled = 0;
    isGameOver = false;

    // Reset player
    player.reset();
  }

  @override
  void onTapDown(TapDownInfo info) {
    if (isGameOver) return;

    // Jump if tap is in the upper half of the screen
    if (info.eventPosition.global.y < size.y / 2) {
      player.jump();
    } else {
      // Move left or right based on tap position
      final tapX = info.eventPosition.global.x;
      if (tapX < size.x / 3) {
        player.moveLeft();
      } else if (tapX > size.x * 2 / 3) {
        player.moveRight();
      }
    }
  }

  @override
  KeyEventResult onKeyEvent(
      KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    if (isGameOver) return KeyEventResult.ignored;

    if (event is KeyDownEvent) {
      if (event.logicalKey == LogicalKeyboardKey.space ||
          event.logicalKey == LogicalKeyboardKey.arrowUp) {
        player.jump();
        return KeyEventResult.handled;
      } else if (event.logicalKey == LogicalKeyboardKey.arrowLeft) {
        player.moveLeft();
        return KeyEventResult.handled;
      } else if (event.logicalKey == LogicalKeyboardKey.arrowRight) {
        player.moveRight();
        return KeyEventResult.handled;
      }
    }

    return KeyEventResult.ignored;
  }
}
