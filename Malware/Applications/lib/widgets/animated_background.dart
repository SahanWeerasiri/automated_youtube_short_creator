import 'package:flutter/material.dart';

class AnimatedBackground extends StatefulWidget {
  const AnimatedBackground({super.key});

  @override
  State<AnimatedBackground> createState() => _AnimatedBackgroundState();
}

class _AnimatedBackgroundState extends State<AnimatedBackground>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 20),
    )..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                HSVColor.fromAHSV(
                  1.0,
                  (_controller.value * 360) % 360,
                  0.6,
                  0.8,
                ).toColor(),
                HSVColor.fromAHSV(
                  1.0,
                  ((_controller.value * 360) + 60) % 360,
                  0.7,
                  0.7,
                ).toColor(),
              ],
              stops: const [0.0, 1.0],
            ),
          ),
          child: Stack(
            children: [
              // Temple silhouette at the bottom
              Positioned(
                bottom: 0,
                left: 0,
                right: 0,
                child: Image.asset(
                  'assets/images/temple_silhouette.png',
                  fit: BoxFit.fitWidth,
                  color: Colors.black.withOpacity(0.1),
                  colorBlendMode: BlendMode.srcATop,
                ),
              ),
              // Overlay pattern
              Opacity(
                opacity: 0.1,
                child: CustomPaint(
                  painter: BackgroundPatternPainter(
                    progress: _controller.value,
                  ),
                  size: Size.infinite,
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}

class BackgroundPatternPainter extends CustomPainter {
  final double progress;

  BackgroundPatternPainter({required this.progress});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    // Draw a grid of ancient temple patterns
    final patternSize = size.width / 10;
    final int xCount = (size.width / patternSize).ceil();
    final int yCount = (size.height / patternSize).ceil();
    for (var xi = 0; xi < xCount; xi++) {
      for (var yi = 0; yi < yCount; yi++) {
        final double x = xi * patternSize;
        final double y = yi * patternSize;
        final rect = Rect.fromLTWH(
          x + (progress * patternSize / 2),
          y + (progress * patternSize / 2),
          patternSize,
          patternSize,
        );

        // Draw different patterns
        final patternType = ((x + y) ~/ patternSize) % 3;
        switch (patternType) {
          case 0:
            // Spiral
            drawSpiral(canvas, rect, paint);
            break;
          case 1:
            // Zigzag
            drawZigzag(canvas, rect, paint);
            break;
          case 2:
            // Circles
            drawCircles(canvas, rect, paint);
            break;
        }
      }
    }
  }

  void drawSpiral(Canvas canvas, Rect rect, Paint paint) {
    final path = Path();
    final center = rect.center;
    final size = rect.width / 2;

    for (var i = 0; i < 5; i++) {
      final radius = size * (1 - i / 5);
      path.addOval(Rect.fromCircle(center: center, radius: radius));
    }

    canvas.drawPath(path, paint);
  }

  void drawZigzag(Canvas canvas, Rect rect, Paint paint) {
    final path = Path();
    path.moveTo(rect.left, rect.top);

    final steps = 5;
    final stepWidth = rect.width / steps;
    final stepHeight = rect.height / steps;

    for (var i = 0; i < steps; i++) {
      if (i % 2 == 0) {
        path.lineTo(rect.left + (i + 1) * stepWidth, rect.top);
        path.lineTo(rect.left + (i + 1) * stepWidth, rect.top + stepHeight);
      } else {
        path.lineTo(rect.left + (i + 1) * stepWidth, rect.top + stepHeight);
        path.lineTo(rect.left + (i + 1) * stepWidth, rect.top);
      }
    }

    canvas.drawPath(path, paint);
  }

  void drawCircles(Canvas canvas, Rect rect, Paint paint) {
    final center = rect.center;
    final radius = rect.width / 4;

    canvas.drawCircle(center, radius, paint);
    canvas.drawCircle(
      Offset(center.dx - radius, center.dy - radius),
      radius / 2,
      paint,
    );
    canvas.drawCircle(
      Offset(center.dx + radius, center.dy - radius),
      radius / 2,
      paint,
    );
    canvas.drawCircle(
      Offset(center.dx - radius, center.dy + radius),
      radius / 2,
      paint,
    );
    canvas.drawCircle(
      Offset(center.dx + radius, center.dy + radius),
      radius / 2,
      paint,
    );
  }

  @override
  bool shouldRepaint(BackgroundPatternPainter oldDelegate) {
    return oldDelegate.progress != progress;
  }
}
